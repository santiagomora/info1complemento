Hemos introducido un ciclo en el programa client.c que 
hace 10000 conexiones al servidor. 
Al intentarlo contra el servidor del ejercicio 13.1:
	observamos que los procesos hijos quedan en
estado zombie hasta que termina el proceso principal
(SIGSTOP) o Ctrl+C.
	si añadimos un sig handler para liberar los 
pid a medida que cada hijo termina su ejecucion (SIGCHLD)
que invoque el syscall wait(NULL), no todos los procesos
hijo terminan adecuadamente (hay algunos que no terminan).
	si esperamos que el programa termine con todas 
las instancias hijo, (server en e2 y e3) observamos que 
se cierran correctamente, quedando el proceso principal
en estado S (int sleep).
	Introducimos en el server de e4 una variable global
cctr  que nos permite limitar el maximo de conexiones posibles 
a 2000. Disminuimos esta variable a medida que vayan terminando
los procesos hijos con la llamada waitpid, de esta manera se 
aceptan progresivamente nuevas conexiones. Cuando llega 
la señal SIGCHLD del primer proceso hijo, empezamos a aceptar
nuevas conexiones porque el proceso sale del estado pause().
	al consultar la cantidad de procesos corriendo en el 
sistema cada 5 segundos (tiempo usado para simular retardo en 
los procesos hijo) observamos que siempre se mantiene menor o
igual a 2000 (maxima cantidad de conexiones definidas MAX_CONN).
cctr aumenta más rapidamente en el main que en el handler de 
SIGCHLD. (no se termina de liberar completamente las 2000 co-
nexiones originales) 
